"""
This file runs Expectation Maximisation Algorithm for binary digit classification.
Note: The binary digits text file and this code file should be in the same folder level.
"""
# -------------------------------------------------------------------------------------------------------------------- #
# Standard Library
# Third Party
import numpy as np
import matplotlib.pyplot as plt

# Private


# -------------------------------------------------------------------------------------------------------------------- #
class ImageEM:
    def __init__(self, X: np.array, pi_weights: np.array, pixel_comp: np.array):
        """
        Initialise Expectation Maximisation algorithm.
        Args:
            X:
                An array containing image data (N by D).
            pi_weights:
                An array of mixture/weight components (K by 1).
            pixel_comp:
                An array containing Bernoulli distribution of pixels across each cluster (K by D).
        Returns:
            N/A
        """
        self.X = X
        self.pi_weights = pi_weights
        self.pixel_comp = pixel_comp
        self.ll_values = []
        self.r_n_k = None
        self.iter_stop = None

    def bernoulli_dist_data(self) -> np.array:
        """
        Given a dataset of images, X, find the probability that each image is generated by a D-dimensional multivariate
        Bernoulli distribution p, corresponding to a K dimensional π vector i.e. p(x|p_k)=P.
        Args:
            N/A
        Returns:
            An array containing probabilities (N by K).
        """
        # Store conditional probabilities on Bernoulli parameter p
        proba_X = np.zeros((self.X.shape[0], self.pixel_comp.shape[0]))
        # Loop over each image
        for n in range(self.X.shape[0]):
            # Once a cluster is chosen, loop over each Bernoulli parameter p_k
            for k in range(self.pixel_comp.shape[0]):
                # This calculates probability over D independent pixels
                proba_X[n, k] = np.prod(
                    (self.pixel_comp[k]) ** self.X[n]
                    * (1 - self.pixel_comp[k]) ** (1 - self.X[n])
                )
        return proba_X

    def e_step(self) -> np.array:
        """
        Compute responsibilities for the E-step of Expectation Maximisation.
        Args:
            N/A
        Returns:
            An array containing responsibilities (N by K).
        """
        # Calculate P(x|p)
        proba_X = self.bernoulli_dist_data()
        # Calculate numerator i.e. π_k * P_k(x|p)
        proba_X = proba_X * self.pi_weights
        # Calculate denominator i.e. sum(π_k * P_k(x|p))
        row_sums = proba_X.sum(axis=1)[:, np.newaxis]
        # Return responsibilities
        return proba_X / row_sums

    def m_step(self, r_n_k: np.array):
        """
        Compute maximising parameters for E{log(P(x,s|π,p_)} with respect to p(s = k|π, p) = q(s) for the M-step of Expectation Maximisation.
        Args:
            r_n_k:
                An array of responsibility values.
        Returns:
            Tuple of arrays containing updated mixture/weight components (π) and pixel components (P).
        """
        # Update mixture/weight components
        A_k = np.sum(r_n_k, axis=0)
        self.pi_weights = A_k / r_n_k.shape[0]
        # Update pixel components
        self.pixel_comp = r_n_k.T @ self.X / A_k.reshape(-1, 1)

    def expected_ll(self, r_n_k: np.array) -> float:
        """
        Calculate E{log(P(x,s|π,p_)}.
        Args:
            r_n_k:
                An array of responsibility values.
        Returns:
            A probability likelihood value.
        """
        # Calculate expected joint probability
        e_ll = 0
        for n in range(self.X.shape[0]):
            k_sum = 0
            for k in range(self.pixel_comp.shape[0]):
                # Using log to avoid numerical pitfalls
                first_term = r_n_k[n, k]
                second_term = np.log(self.pi_weights[k])
                third_term = np.log(
                    np.prod(
                        (self.pixel_comp[k]) ** self.X[n]
                        * (1 - self.pixel_comp[k]) ** (1 - self.X[n])
                    ).clip(min=1e-25)
                )
                k_sum += first_term * (second_term + third_term)
            # Add to log joint
            e_ll += k_sum
        return e_ll

    def run_alg(self, num_iter: int, epsilon: float):
        """
        Run Expectation Maximisation algorithm.
        Args:
            num_iter:
                An integer allowed up to the number of iterations for Expectation Maximisation model to run.
                Note: The Expectation Maximisation model might stop before this value if it converges.
            epsilon:
                Convergence bound for expected log likelihood.
        Returns:
            A tuple containing the mixture/weights and pixel components.
        """
        # Initialise likelihood
        self.ll_values.append(self.expected_ll(r_n_k=self.e_step()))
        # Loop over number of iterations
        for i in range(num_iter):
            # E-Step & M-Step
            self.m_step(r_n_k=self.e_step())
            # Check convergence
            ll_new = self.expected_ll(r_n_k=self.e_step())
            if np.abs(ll_new - self.ll_values[i]) < epsilon:
                print(
                    f"Expectation Maximisation model has converged after {i} iterations."
                )
                self.r_n_k = self.e_step()
                self.iter_stop = i
                break
            else:
                self.ll_values.append(ll_new)

    @staticmethod
    def plot_img(X: np.array, k: int):
        """
        Plot an image of choice.
        Args:
            X:
                An array containing image data.
            k:
                Mixture component.
        Returns:
            A matplotlib image.
        """
        # Create plot
        plt.figure()
        plt.imshow(np.reshape(X, (8, 8)), interpolation="None", cmap="gray")
        plt.axis("off")
        plt.title(f"Pixel distribution from mixture component {k}")
        # Show plot
        plt.show()

    @staticmethod
    def plot_multiple_img(X: np.array, k: int, num_cols: int, title: bool):
        """
        Plot multiple images of choice.
        Args:
            X:
                An array containing image data.
            k:
                Mixture component.
            num_cols:
                Number of images on each row.
            title:
                If title to be printed.
        Returns:
            A matplotlib image.
        """
        # Create plot
        plt.figure(figsize=(5, 5))
        for n in range(X.shape[0]):
            plt.subplot(10, num_cols, n + 1)
            plt.imshow(np.reshape(X[n, :], (8, 8)), interpolation="None", cmap="gray")
            plt.axis("off")
        if title is True:
            plt.suptitle(
                f"Image 1: Matrix P of cluster {k+1} \n Image 2: Matrix M (Mean of all detected images)"
            )
        else:
            plt.suptitle(f"Matrix P for each cluster")
        plt.show()


# Create main function to run via terminal
def main():
    # Obtain file name
    data = "binarydigits.txt"
    # Load data
    X = np.loadtxt(data)
    # Create list of K multivariate Bernoulli's
    print(
        "Enter a list of mixtures numbers for Expectation Maximisation algorithm (e.g. in format 2, 3, 5):"
    )
    K_list = list(map(int, input().split(",")))
    print("Enter maximum number of iterations for Expectation Maximisation algorithm:")
    num_iter = int(input())
    # Create random initial inputs
    print("Enter number of times to repeat Expectation Maximisation algorithm:")
    n_repeats = int(input())
    # Initialise model to None
    em_model = None
    for K in K_list:
        K_proba_values = []
        K_mean_values = []
        for i in range(n_repeats):
            start_weights = np.random.dirichlet(np.ones(K))
            start_pixel_comp = np.random.uniform(low=0, high=1, size=(K, X.shape[1]))
            # Instantiate model
            em_model = ImageEM(
                X=X, pi_weights=start_weights, pixel_comp=start_pixel_comp
            )
            # Run Expectation Maximisation algorithm
            em_model.run_alg(num_iter=num_iter, epsilon=1e-15)
            # Visualise pixels
            for k in range(K):
                mean_image = None
                # Images best created from cluster k
                try:
                    image_k = np.where(
                        np.array([np.argmax(image) for image in em_model.r_n_k]) == k
                    )[0]
                    # Plot the pixel matrix P and the image sample mean M alongside with their detected images
                    mean_image = X[image_k].mean(axis=0)
                    main_data = np.vstack(
                        (em_model.pixel_comp[k], mean_image, X[image_k])
                    )
                    em_model.plot_multiple_img(
                        X=main_data, k=k, num_cols=10, title=True
                    )
                except TypeError as t:
                    print(f"No images found in cluster {k}.")
                # Store vector
                K_proba_values.append(em_model.pixel_comp[k])
                K_mean_values.append(mean_image)
            # Plot log likelihood
            plt.title(f"Joint Log Likelihood Vs Iteration Number for K={K} (clusters) ")
            plt.xlabel("Iteration Number")
            plt.ylabel("Joint Log Likelihood")
            plt.plot(
                np.arange(0, em_model.iter_stop + 1, 1),
                em_model.ll_values,
                "-og",
                label="Joint Log Likelihood",
            )
            plt.show()
            print(f"Final Expectation Maximisation Results for K={K}")
            print(f"2) Likelihood values: {em_model.ll_values}")
            print(f"3) Mixture/Weights: {em_model.pi_weights}")
        # Plot the learned probability vector and mean as images
        em_model.plot_multiple_img(
            X=np.array(K_proba_values), k=K, num_cols=K, title=False
        )
        em_model.plot_multiple_img(
            X=np.array(K_mean_values), k=K, num_cols=K, title=False
        )


# Execute code via terminal
if __name__ == "__main__":
    main()
